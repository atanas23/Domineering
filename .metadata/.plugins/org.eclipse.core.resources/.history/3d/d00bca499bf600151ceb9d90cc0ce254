
// An abstract two-player game with outcomes in the integers.
// We define a particular game by implementing the abstract methods.
//
// Our approach requires immutable implementations of Board.  We
// require that the only public constructor builds the initial board.
// Other constructors may be used for private purposes.

import java.io.*;
import java.util.*;
import java.lang.*;
import java.lang.Integer;

public abstract class Board<Move> {
	abstract Player nextPlayer();

	abstract Set<Move> availableMoves();

	abstract int value();

	abstract int hValue();

	abstract Board<Move> play(Move move);

	// Constructs the game tree of the board using the minimax algorithm
	// (without alpha-beta pruning):
	public GameTree<Move> tree() {
		if (availableMoves().isEmpty())
			return new GameTree<Move>(this, new Nil<Entry<Move, GameTree<Move>>>(), value());
		else
			return (nextPlayer() == Player.MAXIMIZER ? maxTree() : minTree());
	}

	// Two helper methods for that, which call the above method tree:
	public GameTree<Move> maxTree() {
		assert (!availableMoves().isEmpty());

		int optimalOutcome = Integer.MIN_VALUE;
		LList<Entry<Move, GameTree<Move>>> children = new Nil<Entry<Move, GameTree<Move>>>();
		for (Move m : availableMoves()) {
			GameTree<Move> subtree = play(m).tree();
			children = children.append(new Cons<Entry<Move, GameTree<Move>>>(
					new Entry<Move, GameTree<Move>>(m, subtree), new Nil<Entry<Move, GameTree<Move>>>()));
			optimalOutcome = Math.max(optimalOutcome, subtree.optimalOutcome());
			if (optimalOutcome == 1) {
				break;
			}
		}
		return new GameTree<Move>(this, children, optimalOutcome);
	}

	public GameTree<Move> minTree() {
		assert (!availableMoves().isEmpty());

		int optimalOutcome = Integer.MAX_VALUE;
		LList<Entry<Move, GameTree<Move>>> children = new Nil<Entry<Move, GameTree<Move>>>();

		for (Move m : availableMoves()) {
			GameTree<Move> subtree = play(m).tree();
			children = children.append(new Cons<Entry<Move, GameTree<Move>>>(
					new Entry<Move, GameTree<Move>>(m, subtree), new Nil<Entry<Move, GameTree<Move>>>()));
			optimalOutcome = Math.min(optimalOutcome, subtree.optimalOutcome());
			System.err.println(optimalOutcome);
			if (optimalOutcome == -1) {
				break;
			}
		}
		return new GameTree<Move>(this, children, optimalOutcome);
	}
}
