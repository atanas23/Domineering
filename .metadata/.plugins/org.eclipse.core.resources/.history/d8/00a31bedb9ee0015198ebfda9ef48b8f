// Game trees for abstract games two-person games with outcomes in the
// type of integers, parametrized by a type of moves.

import java.util.*;

public class GameTree2<Move> {
  private final Board2<Move> board;
  private final LList<Entry<Move,GameTree2<Move>>> children;
  private final int optimalOutcome; 

  public GameTree2(Board2<Move> board, 
		  LList<Entry<Move,GameTree2<Move>>> children, 
                  int optimalOutcome) {

    assert(board != null && children != null);
    this.board = board;
    this.children = children;
    this.optimalOutcome = optimalOutcome;
  }

  public boolean isLeaf() {
    return(children.isEmpty());
  }

  // Getter methods:
  public Board2<Move> board () {
    return board;
  }

  public LList<Entry<Move,GameTree2<Move>>> children() {
    return children;
  }

  public int optimalOutcome() {
    return optimalOutcome;
  }

  // The following two methods are for game tree statistics only.
  // They are not used for playing.

  // Number of tree nodes:
  public int size() {  // is this going to work?
//    int size = 1;
    LList<Entry<Move, GameTree2<Move>>> tail = children;
    return tail.length() + 1;
  }

  // We take the height of a leaf to be zero (rather than -1):
  public int height() { 
    int height = -1;
    return 1+height;
  }

  // Plays first using this tree:
  public void firstPlayer(MoveChannel<Move> c) {
    c.comment(board + "\nThe optimal outcome is " + optimalOutcome);

    if (isLeaf()) {
      assert(optimalOutcome == board.value());
      c.end(board.value());
    } 
    else {
      Map.Entry<Move,GameTree2<Move>> optimalEntry = null;
      for (Map.Entry<Move,GameTree2<Move>> child : children.entrySet()) {
        if (optimalOutcome == child.getValue().optimalOutcome) {
          optimalEntry = child;
          break;
        }
      }
      assert(optimalEntry != null);
      c.giveMove(optimalEntry.getKey());
      optimalEntry.getValue().secondPlayer(c);
    }
  }

  // Plays second using this tree:
  public void secondPlayer(MoveChannel<Move> c) {
    c.comment(board + "\nThe optimal outcome is " + optimalOutcome);

    if (isLeaf()) {
      assert(optimalOutcome == board.value());
      c.end(board.value());
    } 
    else {
      Move m = c.getMove();
      assert(children.containsKey(m)); // create my own method true/false
      children.get(m).firstPlayer(c); // is .take() the same method?
    }
  }
}
